1. Абстрактен клас: Може да няма конкретна информация (може и да има)
2. Идеята е така да си напишем кода, че да може да бъде лесно използваем, преизползваем и лесно допълним.
3. Други(както и ние) програмисти, да не се интересуват от това, което стои зад кода, а по-скоро от това, което ще се случи, когато го изпълним (абстракция)
4. Интерфейси: Множествено имплементиране, за разлика от несъществуващото множествено наследяване.
5. Разделение по интерфейси (Interface seggragation).
5.1. Разделяме цялостните методи в един клас на групи от методи в различни интерфейси (Методите в класа Принтер, които отговарят за частите му в интерфейс за Машина, методите, които отговарят за писането в интерфейс за Писане, методите които отговарят за свързването към мрежата, компютъра и т.н. в интерфейс за Свръзване)


Защо капсулираме (Encapsulation):
1. Централизираме мястото за валидация, което позволява на използвателите (ние, други програмисти) да не се интересуваме от тези правила, а просто да ползваме. С други думи, ако се появи ново правило, отново ще минем през него, без да дописваме код при клиента (ползвателя).
2. Колкото повече публични неща - толкова по-малко поле за промяна. Не може да промениш името, модификатора за достъп, грешките които връща и т.н., защото евентуално нашите клиенти го ползват (метода, полето...) и очакват старото му поведение, име, грешки...